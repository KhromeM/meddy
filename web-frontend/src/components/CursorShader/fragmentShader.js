export const fragmentShaderCursor = `precision highp float;\n#define GLSLIFY 1\nuniform float u_time;\nuniform vec2 u_res;\nuniform float u_scrollable;\nuniform sampler2D u_bufferTexture;\nuniform vec2 u_mousePos;\nuniform vec3 u_circleColorStart;\nuniform vec3 u_circleColorMiddle;\nuniform vec3 u_circleColorEnd;\nuniform float u_filled;\nuniform float u_speed;\nuniform float u_pagePos;\nuniform float u_scrollPos;\n\nfloat limit(float x) {\n  // Limit a number to lie between 0.0 and 1.0\n  return clamp(x, 0.0, 1.0);\n}\n\nfloat enforceMin(float x, float amount) {\n  // Make sure that any numbers that fall below the textures precision limits are still computed\n  float minimum = 0.003;\n  // If between -min and 0 set to -min\n  if (x >= -minimum && x < 0.0) x = -minimum;\n  // If between min and 0 set to min\n  if (x <= minimum && x > 0.0) x = minimum;\n  return x * amount;\n}\n\nvec3 getCircleColor(vec3 start, vec3 middle, vec3 end, float progress) {\n  // Find the color between start and end based on progress\n  vec3 circleColor = mix(start, end, progress);\n  // Mix in the middle color\n  float halfProgressOffset = limit(abs(progress - .50) * 3.0);\n  circleColor = mix(middle, circleColor, halfProgressOffset);\n  return circleColor;\n}\n\nvec2 rotateCoord(vec2 origin, float angle, vec2 coord) {\n  // Remove origin value\n  coord.x -= origin.x;\n  coord.y -= origin.y;\n  // Rotate\n  float s = sin(angle);\n  float c = cos(angle);\n  float xnew = coord.x * c - coord.y * s;\n  float ynew = coord.x * s + coord.y * c;\n  // Re-add origin values\n  coord.x = xnew + origin.x;\n  coord.y = ynew + origin.y;\n  return coord;\n}\n\nvec2 offsetCoord(vec2 mouse) {\n  mouse.x += 2.0 + (10.0 * u_speed);\n  return mouse;\n}\n\nfloat getDistance(vec2 mouse, vec2 coord, vec2 size) {\n  vec2 mouseOffset = offsetCoord(mouse.xy);\n  mouseOffset = rotateCoord(mouse.xy, u_time / -25.0, mouseOffset);\n  // Get the distance between two coords with some extra logic to calc and limit our circle size\n  float mousePixelDistance = distance(mouseOffset.xy, coord.xy);\n  float mousePixelAngle = dot(mouseOffset.xy, coord.xy);\n  float circleSize = max(size.x / 20.0, 45.0) + (u_filled * max(size.x, size.y) * 2.0) + (u_speed * 40.0);\n  return (1.0 - limit((mousePixelDistance / circleSize))) / (4.0 - (2.0 * u_speed));\n}\n\nvec3 fade(vec4 pixel, vec4 color, float fadeAmount) {\n  vec3 diff = vec3(color.r - pixel.r, color.g - pixel.g, color.b - pixel.b);\n\n  // Reduce\n  diff = diff * vec3(0.1 - (0.09997 * u_speed));\n\n  diff = vec3(\n    enforceMin(diff.r, fadeAmount),\n    enforceMin(diff.g, fadeAmount),\n    enforceMin(diff.b, fadeAmount)\n  );\n  return diff;\n}\n\nvoid main() {\n  // Get this pixel\n  vec2 pixel = gl_FragCoord.xy / u_res.xy;\n  // Update mouse Y pos\n  vec2 mousePos = vec2(u_mousePos.x, u_res.y - u_mousePos.y - (u_scrollPos * u_scrollable));\n  // vec2 mousePos = vec2(u_mousePos.x, u_res.y - u_mousePos.y - (u_scrollPos * u_scrollable));\n  // Get this pixel but on the previous render\n  vec4 prevPixel = texture2D(u_bufferTexture, pixel);\n  // Base BG color\n  vec4 bgColor = vec4(0.992,0.961,0.929, 1.0);\n  // Circle color\n  vec3 circleColor = getCircleColor(\n    u_circleColorStart,\n    u_circleColorMiddle,\n    u_circleColorEnd,\n    u_pagePos\n  );\n\n  // Catch the first ever render and set a base color\n  // Might be possible to make this faster!\n  if (prevPixel.rgb == vec3(0.0)) {\n    prevPixel.rgba = bgColor;\n  }\n\n  // Alter the cursor position based on scroll\n  // mousePos.y = mousePos.y + (u_scrollPos * u_res.y);\n  // pixel.y = pixel.y - (u_scrollPos * u_res.y);\n\n  // Get the distance of the current pixel from the mouse\n  float dist = getDistance(mousePos.xy, gl_FragCoord.xy, u_res.xy);\n\n  // Mix the previous pixel with the circle color based on distance from mouse\n  vec4 color = mix(\n    prevPixel.rgba,\n    vec4(circleColor.rgb, 1.0),\n    vec4(dist)\n  );\n\n  // Set color of the pixel\n  gl_FragColor = color.rgba;\n\n  // Run the pixel through the fade function with extra value to ensure that fade only runs once every 2 frames\n  // vec3 factor = fade(gl_FragColor, bgColor, floor(mod(u_time, 2.0)));\n  vec3 factor = fade(gl_FragColor, bgColor, 1.0);\n\n  // Apply any fade that is returned\n  gl_FragColor.rgb += factor.rgb;\n}`;
